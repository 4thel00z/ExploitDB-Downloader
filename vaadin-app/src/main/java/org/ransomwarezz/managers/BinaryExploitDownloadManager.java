package org.ransomwarezz.managers;

import org.ransomwarezz.entities.DownloadResult;
import org.ransomwarezz.entities.Downloadable;
import org.ransomwarezz.utils.PathUtils;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URL;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.stream.Collectors;

/**
 * Created by moe on 11/07/17.
 */
public class BinaryExploitDownloadManager implements DownloadManager {

    private static int threadCount = 20;
    private static DownloadManager INSTANCE;

    public static BinaryExploitDownloadManager getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new BinaryExploitDownloadManager();
        }
        return (BinaryExploitDownloadManager) INSTANCE;
    }

    @Override
    public <T extends Collection> List<Future<DownloadResult>> download(T downloadables)
            throws InterruptedException {
        return Executors.newFixedThreadPool(threadCount).invokeAll(convert(downloadables));
    }

    public static <T extends Collection<Downloadable>> List<Callable<DownloadResult>> convert(T list) {
        return list.parallelStream().map((downloadable -> convert(downloadable))).collect(Collectors.toList());
    }

    public static Callable<DownloadResult> convert(Downloadable downloadable) {
        return () -> {

            final String filename = getFilePath(downloadable);
            final Path filePath = Paths.get(filename);

            // Don't download a file twice
            if (Files.exists(filePath)) {
                return new DownloadResult(Files.size(filePath), downloadable.getName(), filename);
            }

            URL website = new URL(downloadable.getDownloadUrl());
            ReadableByteChannel readableByteChannel = Channels.newChannel(website.openStream());

            try {
                createDirectoryPath(downloadable);
            } catch (IOException exception) {
                //TODO: add better exception behaviour, logging and resolve error depending on cause
                exception.printStackTrace();
            }

            long size = save(downloadable, readableByteChannel);
            String path = new StringBuilder().append(PathUtils.getWorkingDirectoryAbsolutePath()).append(downloadable.getPath()).toString();
            return new DownloadResult(size, downloadable.getName(), path);
        }
                ;
    }


    private static long save(Downloadable downloadable, ReadableByteChannel readableByteChannel) throws IOException {
        String filePath = getFilePath(downloadable);
        FileOutputStream fileOutputStream = new FileOutputStream(filePath);
        return fileOutputStream.getChannel().transferFrom(readableByteChannel, 0, Long.MAX_VALUE);
    }

    private static String getFilePath(Downloadable downloadable) {
        return new StringBuilder().append(downloadable.getPath()).append(File.separator).append(downloadable.getName()).toString();
    }

    private static void createDirectoryPath(Downloadable downloadable) throws IOException {
        Path path = Paths.get(downloadable.getPath());
        Files.createDirectories(path);
    }
}
